---
title: '`dplyr`: The Yotabites Demo'
author: "Shiv Sundar"
date: "June 5, 2018"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
worldCountries <- read.csv("/Users/Shivkarthi/Documents/GitHub_Repos/RPackagesDemo/data/worldCountries.csv")
library(dplyr)
knitr::opts_chunk$set(echo = TRUE)
```

#Introduction
This tutorial was created to inform the user about every function provided by the `dplyr` package. Commonly used and simple functions will include a short use case and demo. 

##The pipe operator
One of the most used tools provided by `dplyr` is the pipe (`%>%`) operator. We can use it to chain together multiple functions. It's kind of like saying: do this, **then** do this, **then** do this. We'll cover the use and syntax for it as we go.

##Commonly used `dplyr` functions

###Are these two data frames the same?
The `all_equal()` function is used to compare two data frames. One can use this function to check for equality without considering row order, column order, or both.

####Usage
`all_equal(df1, df2, ignore_col_order = TRUE, ignore_row_order = TRUE, convert = FALSE, ...)`

####Parameters
* `df1`, `df2`: dataframes to compare.
* `ignore_col_order`: should the ordering of columns be ignored?
* `ignore_row_order`: should the ordering of rows be ignored?
* `convert`: should the function attempt to coerce factors to characters and integers to doubles?
* `...`: **not used**. required to comply with `all.equal()` usage.

####Examples
```{r include=FALSE}
worldCountries1 <- sample_n(worldCountries[ , c("Country", "Population", "Phones..per.1000.", "Region")], 15)
worldCountriesMix <- worldCountries1[sample(nrow(worldCountries1)), sample(ncol(worldCountries1))]
```

Here we see what the data looks like.
```{r}
head(worldCountries1)
head(worldCountriesMix)
```

Here we test different variations of the function.
```{r}
all_equal(worldCountries1, worldCountriesMix)
all_equal(worldCountries1, worldCountriesMix, TRUE, FALSE)
all_equal(worldCountries1, worldCountriesMix, FALSE, FALSE)
```

###I want to sort my data by a specified order!
Data can be sorted by using the `arrange()` function. It sorts using by using the natural order of the data type. Factors are normally sorted by alphabetical order. To order them differently, please use the `levels()` function.

####Usage
`arrange(.data, ...)`

####Parameters
* `.data`: the dataframe to arrange
* `...`: the columns to sort by

####Examples
```{r}
head(arrange(worldCountries1, Population))
head(worldCountries1 %>%
  arrange(Phones..per.1000.))
```

We just saw the first use of the pipe operator! In English, we took the data frame `worldCountries1`, **then** arranged its data by the values in the `Phones..per.1000.` column. We can accomplish this task without using the pipe operator as well.

```{r}
head(arrange(worldCountries1, Phones..per.1000.))
```

Functions provided by `dplyr` support both options that we just covered. It's up to your preference. However, in this demo we will use the pipe operator to familiarize you with its use.

###Which values in a vector fall between 10.4 and 73?
How can we answer this question? Well, `dplyr` actually provides us with a function called `between()`. That's convenient! 

####Usage
`between(vector, min, max)`

####Parameters
* `vector`: the values to check
* `min`: the minimum value (inclusive)
* `max`: the maximum value (inclusive)

####Examples
```{r}
newData <- sample_n(worldCountriesMix, 15)$Population
head(newData)
newData%>%
  between(200000, 7500000)
```

###Getting rid of NAs and replacing them with values in a vector
The `coalesce()` function takes multiple vectors and combines places the first non-NA value in the returned vector.

####Usage
`coalesce(firstVect, ...)`

####Parameters
* `firstVect`: the base vector. One can take this to be the vector that will be returned with its NA values filled if possible
* `...`: any vector that is of length 1 or equal to the length of `firstVect`

####Usage
```{r}
x <- c(1, 6, NA, 3, NA, 4, 2, NA, 5)
y <- c(NA, 2, 5, NA, 3, NA, 6, 4, 1)
coalesce(x, y)
coalesce(y, x)
```

###`arrange()`, but backwards!
`desc()` is a function that is pretty straightforward. It takes every value in the vector and flips the sign. When this function is used in conjunction with `arrange()`, the vector returned is sorted in reverse order.

####Usage
`desc(vec)`

####Parameters
* `vec`: a vector to reverse the signage of each element

####Examples
```{r}
head(worldCountries1$Phones..per.1000.)
desc(worldCountries1$Phones..per.1000.) %>%
  head
```

###Ew! I have replicated data in my table!
A tool provided by `dplyr` that is frequently used for removing duplicate values is the `distinct()` function. It returns a vector with the duplicates removed

####Usage
`distinct(.data, ..., .keep_all = FALSE)`

####Parameters
* `.data`: the tibble to remove values from (at least one is required)
* `...`: other variables to check for uniqueness
* `.keep_all`: should all variables in `.data` be kept?

####Usage
```{r}
worldCountriesTbl <- as_tibble(worldCountries)
worldCountriesTbl %>%
  distinct(Coastline..coast.area.ratio.) %>%
  head
```

###I'm having issues with my `dplyr` installation! What do I do?
`dr_dplyr()` is a maintenance tool provided by `dplyr` to diagnose common problems with the package itself. This function can sometimes show false errors, so only use it if there are problems.

####Usage
`dr_dplyr()`

####Parameters
**N/A**

####Examples
```{r}
dr_dplyr()
```


###I need a more readable description of my tibble.
`explain()` is a function that is similar to `print()` and `str()` but is more focused on human readability while still providing more details about the data.

####Usage
`explain(.data)`

####Parameters
* `.data`: data that needs explaining

####Examples
```{r}
#need to fix this
#explain(worldCountriesTbl)
```

###Is there an easy way to find elements that fit a certain condition?
Well, of course there is! It's called the `filter()` function. It is different from using subsets (like `[]`) because it does not return `NA` values.

####Usage
`filter(.data, ...)`

####Parameters
* `.data`: data to pass through the filter
* `...`: 

####Examples
```{r}
head((worldCountries %>%
  filter(between(GDP....per.capita., 2000, 5000)))[1])
```

###Grouping multiple rows together for batch operations
The `group_by()` function is used to easily perform operations such as `mean()` for all values that fall into a category. It is generally used with the `summarise()` function to show outputs by the generated groups.

####Usage
`group_by(.data, ..., add = FALSE)`

####Parameters
* `.data`: object to group variables together
* `...`: variables that will be grouped together
* `add`: should this operation override existing groups?

####Examples
```{r}
worldCountriesTbl %>%
  group_by(Region) %>%
  summarise(mean(Population))
```

###Joining multiple tbls into one
Sometimes you have two tbls with related data. You could continually perform operations by referring to each separately, but one can use the `join()` function to place them into one.

####Usage
`inner_join(left, right, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)`
`left_join(left, right, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)`
`right_join(left, right, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)`
`full_join(left, right, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)`
`semi_join(left, right, by = NULL, copy = FALSE, ...)`
`anti_join(left, right, by = NULL, copy = FALSE, ...)`

####Parameters
* `left`: a tbl 
* `right`: a tbl
* `by`: a character vector of column names to join by. if this remains `NULL`, then this function will join the tbls by columns that have the same name.
* `copy`: if `TRUE`, then `right` will be copied into the same data source as `left`
* `suffix`: specify in the output whether there are any other duplicate columns that weren't joined

####Examples
```{r}
worldCountriesNew <- worldCountries[ , c("Area..sq..mi..", "Net.migration", "Arable....")]
worldCountries1 <- worldCountries[ , c("Other....", "Region", "Crops....", "Arable....", "Phones..per.1000.", "Population")]
head(full_join(worldCountries1, worldCountriesNew))
```

###I need to add some extra columns based on existing data for future use
The `mutate()` function is great for creating extra columns in a data frame 

####Usage


####Parameters


####Examples
```{r}
head(worldCountries1 %>%
  mutate("Total Phones" = Phones..per.1000. * Population * 1000))
```

###
n()

####Usage


####Parameters


####Examples
```{r}
worldCountries %>%
  summarise(n())
worldCountries1 %>%
  summarise(n())
```

###
na_if()

####Usage


####Parameters


####Examples
```{r}
x <- c(1:7, 3, 3)
x <- sample(x)
na_if(x, 3)
```

###


####Usage


####Parameters


####Examples
```{r}
y <- (x + .073)
near(x, y)
y <- (x + .000000003)
near(x, y)
```

###


####Usage


####Parameters


####Examples
```{r}
n_distinct(x)
```

###


####Usage


####Parameters


####Examples
```{r}
summarise(starwars, n())
```

###


####Usage


####Parameters


####Examples
```{r}
head(worldCountries %>%
       pull(Population))
```

###


####Usage


####Parameters


####Examples
```{r}
head(x)
y <- sample(x)
head(y)
```

###


####Usage


####Parameters


####Examples
```{r}
head(select(sample_n(starwars, 6), c("name", "species")))
```

###


####Usage


####Parameters


####Examples
```{r}
head(starwars)
slice(starwars, c(1, 3, 4))
```

###


####Usage


####Parameters


####Examples

###


####Usage


####Parameters


####Examples

###


####Usage


####Parameters


####Examples

###


####Usage


####Parameters


####Examples

##Datasets provided by `dplyr`
These datasets are bundled with the `dplyr` package for testing and manipulating.

* `band_members`
* `band_instruments`
* `band_instruments2`
* `nasa`
* `starwars`
* `storms`

##Other functions not covered

all_vars
arrange_all
as.table.tbl_cube
as.tbl_cube
auto_copy
bind
case_when
compute
copy_to
cumall
do
filter_all
funs
groups
group_by_all
ident
if_else
join.tbl_df
lead-lag
mutate
na_if
near
nth
order_by
ranking
recode
rowwise
scoped
select_all
select_vars
setops
sql
src_dbi
summarise
summarise_all
tally
tbl
tbl_cube
top_n
ungroup
vars